import { DebugElement, ElementRef, Type, EventEmitter } from '@angular/core';
import { Observable } from 'rxjs';
import { ComponentFixture } from '@angular/core/testing';
import { Token } from '../token';
import { DOMSelector } from '../dom-selectors';
import { SpectatorElement, EventEmitterType, KeysMatching, KeyboardEventOptions } from '../types';
import { SpyObject } from '../mock';
import { BaseSpectator } from './base-spectator';
/**
 * @internal
 */
export declare abstract class DomSpectator<I> extends BaseSpectator {
    fixture: ComponentFixture<any>;
    debugElement: DebugElement;
    protected instance: I;
    element: Element;
    constructor(fixture: ComponentFixture<any>, debugElement: DebugElement, instance: I, element: Element);
    inject<T>(token: Token<T>): SpyObject<T>;
    detectChanges(): void;
    query<R extends Element>(selector: string | DOMSelector, options?: {
        root: boolean;
    }): R | null;
    query<R>(directive: Type<R>): R | null;
    query<R>(directiveOrSelector: Type<any> | string, options: {
        read: Token<R>;
    }): R | null;
    queryAll<R extends Element>(selector: string | DOMSelector, options?: {
        root: boolean;
    }): R[];
    queryAll<R>(directive: Type<R>): R[];
    queryAll<R>(directiveOrSelector: Type<any> | string, options: {
        read: Token<R>;
    }): R[];
    queryLast<R extends Element>(selector: string | DOMSelector, options?: {
        root: boolean;
    }): R | null;
    queryLast<R>(directive: Type<R>): R | null;
    queryLast<R>(directiveOrSelector: Type<any> | string, options: {
        read: Token<R>;
    }): R | null;
    setInput<K extends keyof I>(input: Partial<I>): void;
    setInput<K extends keyof I>(input: K, inputValue: I[K]): void;
    output<T, K extends keyof I = keyof I>(output: K): Observable<T>;
    tick(millis?: number): void;
    click(selector?: SpectatorElement): void;
    blur(selector?: SpectatorElement): void;
    focus(selector?: SpectatorElement): void;
    dispatchMouseEvent(selector: string | Element | Window | Document | DebugElement | DOMSelector | ElementRef<any> | undefined, type: string, x?: number, y?: number, event?: MouseEvent): MouseEvent;
    dispatchKeyboardEvent(selector: SpectatorElement, type: string, keyCode: number, target?: Element): KeyboardEvent;
    dispatchKeyboardEvent(selector: SpectatorElement, type: string, key: string, target?: Element): KeyboardEvent;
    dispatchKeyboardEvent(selector: SpectatorElement, type: string, keyAndCode: KeyboardEventOptions, target?: Element): KeyboardEvent;
    dispatchFakeEvent(selector: string | Element | Window | Document | DebugElement | DOMSelector | ElementRef<any> | undefined, type: string, canBubble?: boolean): Event;
    triggerEventHandler<C = any, K extends KeysMatching<C, EventEmitter<any>> = any>(directiveOrSelector: Type<C> | string | DebugElement, eventName: K, eventObj: EventEmitterType<C[K]>): void;
    readonly keyboard: {
        pressKey: (key: string, selector?: SpectatorElement, event?: string) => void;
        pressEscape: (selector?: SpectatorElement, event?: string) => void;
        pressEnter: (selector?: SpectatorElement, event?: string) => void;
        pressTab: (selector?: SpectatorElement, event?: string) => void;
        pressBackspace: (selector?: SpectatorElement, event?: string) => void;
    };
    readonly mouse: {
        contextmenu: (selector?: SpectatorElement) => void;
        dblclick: (selector?: SpectatorElement) => void;
    };
    dispatchTouchEvent(selector: string | Element | Window | Document | DebugElement | DOMSelector | ElementRef<any> | undefined, type: string, x?: number, y?: number): void;
    typeInElement(value: string, selector?: SpectatorElement): void;
    selectOption(selector: string | Element | Window | Document | DebugElement | DOMSelector | ElementRef<any> | undefined, options: string | string[] | HTMLOptionElement | HTMLOptionElement[], config?: {
        emitEvents: boolean;
    }): void;
    private getNativeElement;
    private getDebugElement;
}
