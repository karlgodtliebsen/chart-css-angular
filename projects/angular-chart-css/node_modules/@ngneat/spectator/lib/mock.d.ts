/// <reference types="jasmine" />
/** Credit: Valentin Buryakov */
import { FactoryProvider, Type, AbstractType } from '@angular/core';
declare type Writable<T> = {
    -readonly [P in keyof T]: T[P];
};
/**
 * @publicApi
 */
export interface CompatibleSpy extends jasmine.Spy {
    /**
     * By chaining the spy with and.returnValue, all calls to the function will return a specific
     * value.
     */
    andReturn(val: any): void;
    /**
     * By chaining the spy with and.callFake, all calls to the spy will delegate to the supplied
     * function.
     */
    andCallFake(fn: Function): this;
    /**
     * removes all recorded calls
     */
    reset(): void;
}
/**
 * @publicApi
 */
export declare type SpyObject<T> = T & {
    [P in keyof T]: T[P] extends Function ? T[P] & CompatibleSpy : T[P];
} & {
    /**
     * Casts to type without readonly properties
     */
    castToWritable(): Writable<T>;
};
/**
 * @internal
 */
export declare function installProtoMethods<T>(mock: any, proto: any, createSpyFn: Function): void;
/**
 * @publicApi
 */
export declare function createSpyObject<T>(type: Type<T> | AbstractType<T>, template?: Partial<Record<keyof T, any>>): SpyObject<T>;
/**
 * @publicApi
 */
export declare function mockProvider<T>(type: Type<T> | AbstractType<T>, properties?: Partial<Record<keyof T, any>>): FactoryProvider;
/**
 * @publicApi
 */
export declare type MockProvider = typeof mockProvider;
export {};
