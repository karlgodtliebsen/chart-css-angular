import { installProtoMethods, createComponentFactory as createComponentFactory$1, isType, Spectator as Spectator$1, createHttpFactory as createHttpFactory$1, SpectatorDirective as SpectatorDirective$1, createDirectiveFactory as createDirectiveFactory$1, createServiceFactory as createServiceFactory$1, SpectatorHost as SpectatorHost$1, createHostFactory as createHostFactory$1, SpectatorRouting as SpectatorRouting$1, createRoutingFactory as createRoutingFactory$1, SpectatorPipe as SpectatorPipe$1, createPipeFactory as createPipeFactory$1 } from '@ngneat/spectator';
export { HttpMethod, byAltText, byLabel, byPlaceholder, byRole, byTestId, byText, byTextContent, byTitle, byValue } from '@ngneat/spectator';

/**
 * @publicApi
 */
function createSpyObject(type, template) {
    const mock = Object.assign({}, template) || {};
    installProtoMethods(mock, type.prototype, () => {
        const jestFn = jest.fn();
        const newSpy = jestFn;
        newSpy.andCallFake = (fn) => {
            jestFn.mockImplementation(fn);
            return newSpy;
        };
        newSpy.andReturn = (val) => {
            jestFn.mockReturnValue(val);
        };
        newSpy.reset = () => {
            jestFn.mockReset();
        };
        return newSpy;
    });
    return mock;
}
/**
 * @publicApi
 */
function mockProvider(type, properties) {
    return {
        provide: type,
        useFactory: () => createSpyObject(type, properties)
    };
}

function createComponentFactory(typeOrOptions) {
    return createComponentFactory$1(Object.assign({ mockProvider }, (isType(typeOrOptions) ? { component: typeOrOptions } : typeOrOptions)));
}
class Spectator extends Spectator$1 {
    inject(token, fromComponentInjector = false) {
        return super.inject(token, fromComponentInjector);
    }
}

/**
 * @publicApi
 */
function createHttpFactory(typeOrOptions) {
    return createHttpFactory$1(Object.assign({ mockProvider }, (isType(typeOrOptions) ? { service: typeOrOptions } : typeOrOptions)));
}

/**
 * @publicApi
 */
class SpectatorDirective extends SpectatorDirective$1 {
    inject(token, fromComponentInjector = false) {
        return super.inject(token, fromComponentInjector);
    }
}
function createDirectiveFactory(typeOrOptions) {
    return createDirectiveFactory$1(Object.assign({ mockProvider }, (isType(typeOrOptions) ? { directive: typeOrOptions } : typeOrOptions)));
}

/**
 * @publicApi
 */
function createServiceFactory(typeOrOptions) {
    return createServiceFactory$1(Object.assign({ mockProvider }, (isType(typeOrOptions) ? { service: typeOrOptions } : typeOrOptions)));
}

/**
 * @publicApi
 */
class SpectatorHost extends SpectatorHost$1 {
    inject(token, fromComponentInjector = false) {
        return super.inject(token, fromComponentInjector);
    }
}
function createHostFactory(typeOrOptions) {
    return createHostFactory$1(Object.assign({ mockProvider }, (isType(typeOrOptions) ? { component: typeOrOptions } : typeOrOptions)));
}

/**
 * @publicApi
 */
class SpectatorRouting extends SpectatorRouting$1 {
    inject(token, fromComponentInjector = false) {
        return super.inject(token, fromComponentInjector);
    }
}
/**
 * @publicApi
 */
function createRoutingFactory(typeOrOptions) {
    return createRoutingFactory$1(Object.assign({ mockProvider }, (isType(typeOrOptions) ? { component: typeOrOptions } : typeOrOptions)));
}

/**
 * @publicApi
 */
class SpectatorPipe extends SpectatorPipe$1 {
    inject(token) {
        return super.inject(token);
    }
}
/**
 * @publicApi
 */
function createPipeFactory(typeOrOptions) {
    return createPipeFactory$1(Object.assign({ mockProvider }, (isType(typeOrOptions) ? { pipe: typeOrOptions } : typeOrOptions)));
}

/// <reference types="jest" />

/**
 * Generated bundle index. Do not edit.
 */

export { Spectator, SpectatorDirective, SpectatorHost, SpectatorPipe, SpectatorRouting, createComponentFactory, createDirectiveFactory, createHostFactory, createHttpFactory, createPipeFactory, createRoutingFactory, createServiceFactory, createSpyObject, mockProvider };
//# sourceMappingURL=ngneat-spectator-jest.js.map
